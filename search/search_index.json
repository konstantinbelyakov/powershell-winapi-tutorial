{"config":{"lang":["en","ru"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Tip</p> <p>The content is available in English and Russian. You can use the language switch in the top toolbar of this website (to the left from the search box) to change language.</p> <p>This documentation project is based on the blog post series by Matt Graeber:</p> <ul> <li>Use PowerShell to Interact with the Windows API: Part 1</li> <li>Use PowerShell to Interact with the Windows API: Part 2</li> <li>Use PowerShell to Interact with the Windows API: Part 3</li> </ul> <p>Here you can find tutorials and examples on how to access the Windows API (formerly called the Win32 API) from PowerShell scripts. Tutorials consider three alternative ways of calling the CopyFile function, and demonstrate the creation of a PowerShell module with the <code>Copy-RawItem</code> cmdlet. The custom cmdlet differs from the standard Copy-Item, as it can handle special device object paths, such as paths to files backed up by the Volume Shadow Copy Service:</p> <p><code>\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1_</code></p> <p>Handling of errors thrown by the called Windows API method is also demonstrated.</p> <p></p> <p>Tip</p> <p>Accessing <code>CopyFile</code> is considered as a simple basic example here. You can use a similar approach to access other Windows APIs</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Three Ways to Call a Windows API Method<ul> <li>Use the Add-Type Cmdlet that Calls the Windows API Function</li> <li>Get a Private .NET Method that Calls the Windows API Function</li> <li>Call the Windows API Function from a Dynamically Defined Method</li> </ul> </li> <li>Summary</li> </ul> <p>Note</p> <p>Several sections are not completed yet, the content is under development.</p>"},{"location":"#code-examples","title":"Code Examples","text":"<p>Examples demonstrated in this documentation are available an GitHub: powershell-winapi-tutorial/examples/.</p>"},{"location":"summary/","title":"Summary","text":"<p>This article content is not ready yet\u2026</p>"},{"location":"win32-approaches/","title":"Three Ways to Call a Windows API Method","text":"<p>Windows API functions are very handy for low level tasks, when the close interaction with the operating system is required. There are three ways to access Windows API from PowerShell:</p> <ol> <li>Use the Add-Type Cmdlet that Calls the Windows API Function</li> <li>Get a Private .NET Method that Calls the Windows API Function</li> <li>Call the Windows API Function from a Dynamically Defined Method</li> </ol> <p>In most cases, the first way is sufficient, as it is rather simple and straightforward. However, <code>Add-Type</code> calls the C# compiler (css.exe) and writes temporary files to disk, which may be inappropriate in certain scenarios. Try other two methods if you want to minimize your script footprint on a target system.</p> <p>Most of Windows API functions already have wrappers in .NET APIs, although these wrapper methods may be private. The second way implies finding and accessing an appropriate method.</p> <p>The third option is to use reflection and dynamically generate the code that will call a Windows API function. This approach is handy when the required Windows API function wrapper not present in .NET assemblies loaded by the current PowerShell session, and you also do not want to write temporary files.</p> <p>The table below may help you to choose an appropriate way.</p> Add-Type Cmdlet Private .NET Method Dynamically Defined Method Difficulty Simple Medium Complex Temporary files Yes No No Requires an existing .NET wrapper No Yes No"},{"location":"win32-approaches/add-type/","title":"Use the Add-Type Cmdlet that Calls the Windows API Function","text":"<p>The Add-Type cmdlet adds a specified .NET class to a PowerShell session. This topic demonstrates how to use this cmdlet to access the CopyFile function declared in the kernel32.dll library.</p>"},{"location":"win32-approaches/add-type/#basic-implementation","title":"Basic Implementation","text":"<p>Consider the script that calls the <code>CopyFile</code> function:</p> PowerShell<pre><code>$MethodDefinition = @'\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\npublic static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);\n'@\n$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -Namespace 'Win32' -PassThru\n$Kernel32::CopyFile(\"$($Env:SystemRoot)\\System32\\calc.exe\", \"$($Env:USERPROFILE)\\Desktop\\calc.exe\", $False)\n</code></pre> <p>This script does the following:</p> <ul> <li> <p>The <code>$MethodDefinition</code> variable contains the \u0421# method definition that matches the C++ signature of <code>CopyFile</code>.</p> Expand to see the details <p>C++ signature<pre><code>BOOL CopyFile(\n    [in] LPCTSTR lpExistingFileName,\n    [in] LPCTSTR lpNewFileName,\n    [in] BOOL    bFailIfExists\n);\n</code></pre> C# definition<pre><code>[DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\npublic static extern bool CopyFile(\n    string lpExistingFileName,\n    string lpNewFileName,\n    bool   bFailIfExists\n);\n</code></pre></p> <p>The DllImport attribute indicates that the <code>CopyFile</code> method is exposed by the kernel32.dll library as a static entry point.</p> <p>Note the correct translation of C++ parameter types to corresponding .NET types:</p> C/C++ Type .NET Type BOOL bool LPCTSTR string </li> <li> <p>The <code>Add-Type</code> cmdlet creates the <code>Kernel32</code> class containing the <code>CopyFile</code> method defined at the previous step.</p> </li> <li> <p>The last line of code calls the <code>Kernel32::CopyFile</code> method to copy the calc.exe file from Windows\\System32 folder to the desktop.</p> </li> </ul>"},{"location":"win32-approaches/add-type/#further-improvements","title":"Further Improvements","text":"<ul> <li>It may be inconvenient to edit C# code as a string inside the PowerShell script. You can save the C# code to a separate file (e.g., CopyFile.cs) and get the file content using the Get-Content cmdlet.</li> <li>You can declare the <code>Copy-RawItem</code> commandlet in a custom PowerShell module file \u2014 to make your code reusable.</li> <li>You can implement error handling \u2014 throw an exception when <code>CopyFile</code> fails.</li> </ul> <p>The code below demonstrates the CopyRawItem.psm1 module implementation, with the above improvements:</p> PowerShell Module<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $MethodDefinition = Get-Content -Path .\\CopyFile.cs\n    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -Namespace 'Win32' -PassThru\n    $CopyResult = $Kernel32::CopyFile($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists']))\n    if ($CopyResult -eq $False) {\n        throw New-Object ComponentModel.Win32Exception(\n            [System.Runtime.InteropServices.Marshal]::GetLastWin32Error())\n    }\n    else {\n        Write-Output (Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>You can import this module and call <code>Copy-RawItem</code> from your script as follows:</p> PowerShell<pre><code>Import-Module ./CopyRawItem.psm1\nCopy-RawItem \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SAM C:\\temp\\SAM -FailIfExists\n</code></pre> <p>Here, the security account manager database file is copied from the volume shadow copy to a temporary folder (which is impossible when using standard Copy-Item cmdlet). If you run <code>Copy-RawItem</code> twice, you will see the \u201cfile exists\u201d error:</p> <p></p> <p>If you specify an incorrect path, the \u201csystem cannot find the path specified\u201d error is displayed.</p> <p>Tip</p> <p>If you receive the \u201cAccess is denied\u201d error when accessing the shadow copy, run your PowerShell session as administrator.</p> <p>Note</p> <p>You can get the complete code demonstrated here at GitHub: powershell-winapi-tutorial/examples/add-type.</p>"},{"location":"win32-approaches/private-method/","title":"Get a Private .NET Method that Calls the Windows API Function","text":"<p>This article content is not ready yet\u2026</p> PowerShell Module<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $mscorlib = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { \n        $_.Location -and ($_.Location.Split('\\')[-1] -eq 'mscorlib.dll')\n    }\n    $Win32Native = $mscorlib.GetType('Microsoft.Win32.Win32Native')\n    $CopyFileMethod = $Win32Native.GetMethod(\n        'CopyFile', ([Reflection.BindingFlags] 'NonPublic, Static'))\n    $CopyResult = $CopyFileMethod.Invoke(\n        $null, @($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists'])))\n    $HResult = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\n    if ($CopyResult -eq $False -and $HResult -ne 0) {\n        throw New-Object ComponentModel.Win32Exception($HResult)\n    }\n    else {\n        Write-Output(Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>Note</p> <p>You can get the complete code demonstrated here at GitHub: powershell-winapi-tutorial/examples/private-method.</p>"},{"location":"win32-approaches/reflection/","title":"Call the Windows API Function from a Dynamically Defined Method","text":"<p>This article content is not ready yet\u2026</p> PowerShell Module<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $DynAssembly = New-Object System.Reflection.AssemblyName('Win32Lib')\n    $AssemblyBuilder = [AppDomain]::CurrentDomain.DefineDynamicAssembly(\n        $DynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)\n    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('Win32Lib', $False)\n    $TypeBuilder = $ModuleBuilder.DefineType('Kernel32', 'Public, Class')\n    $PInvokeMethod = $TypeBuilder.DefineMethod('CopyFile', [Reflection.MethodAttributes] 'Public, Static',\n        [Bool], [Type[]] @([String], [String], [Bool]))\n    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))\n    $FieldArray = [Reflection.FieldInfo[]] @(\n        [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('PreserveSig'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('CallingConvention'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('CharSet')\n    )\n    $FieldValueArray = [Object[]] @(\n        'CopyFile',\n        $True,\n        $True,\n        [Runtime.InteropServices.CallingConvention]::Winapi,\n        [Runtime.InteropServices.CharSet]::Unicode\n    )\n    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(\n        $DllImportConstructor, @('kernel32.dll'), $FieldArray, $FieldValueArray)\n    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)\n    $Kernel32 = $TypeBuilder.CreateType()\n    $CopyResult = $Kernel32::CopyFile($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists']))\n    if ($CopyResult -eq $False) {\n        throw New-Object ComponentModel.Win32Exception(\n            [System.Runtime.InteropServices.Marshal]::GetLastWin32Error())\n    }\n    else {\n        Write-Output (Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>Note</p> <p>You can get the complete code demonstrated here at GitHub: powershell-winapi-tutorial/examples/reflection.</p>"},{"location":"ru/","title":"\u0412\u0432\u0435\u0434\u0435\u043d\u0438\u0435","text":"<p>\u041f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430</p> <p>\u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u043d\u0430 \u0440\u0443\u0441\u0441\u043a\u043e\u043c \u0438 \u0430\u043d\u0433\u043b\u0438\u0439\u0441\u043a\u043e\u043c \u044f\u0437\u044b\u043a\u0430\u0445. \u0427\u0442\u043e\u0431\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u044f\u0437\u044b\u043a, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0432\u0435\u0440\u0445\u043d\u0435\u0439 \u043f\u0430\u043d\u0435\u043b\u0438 \u0441\u0430\u0439\u0442\u0430 (\u0441\u043b\u0435\u0432\u0430 \u043e\u0442 \u043f\u043e\u0438\u0441\u043a\u0430).</p> <p>\u042d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u043e\u0441\u043d\u043e\u0432\u0430\u043d \u043d\u0430 \u0441\u0435\u0440\u0438\u0438 \u0441\u0442\u0430\u0442\u0435\u0439 \u041c\u044d\u0442\u0442\u0430 \u0413\u0440\u0435\u0431\u0435\u0440\u0430:</p> <ul> <li>Use PowerShell to Interact with the Windows API: Part 1</li> <li>Use PowerShell to Interact with the Windows API: Part 2</li> <li>Use PowerShell to Interact with the Windows API: Part 3</li> </ul> <p>\u0417\u0434\u0435\u0441\u044c \u0432\u044b \u043d\u0430\u0439\u0434\u0435\u0442\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 \u0438 \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a Windows API (\u0440\u0430\u043d\u0435\u0435 \u043d\u0430\u0437\u044b\u0432\u0430\u043b\u043e\u0441\u044c Win32 API) \u0438\u0437 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0435\u0432 \u043d\u0430 PowerShell. \u0420\u0430\u0441\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u0442\u0440\u0438 \u0430\u043b\u044c\u0442\u0435\u0440\u043d\u0430\u0442\u0438\u0432\u043d\u044b\u0445 \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u0432 \u0432\u044b\u0437\u043e\u0432\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 CopyFile \u0438 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u043e\u0434\u0443\u043b\u044f PowerShell, \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0435\u0433\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442 <code>Copy-RawItem</code>. \u042d\u0442\u043e\u0442 \u043a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442 \u043e\u0442\u043b\u0438\u0447\u0430\u0435\u0442\u0441\u044f \u043e\u0442 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0433\u043e Copy-Item \u0442\u0435\u043c, \u0447\u0442\u043e \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0443\u0442\u0438 \u043a \u043e\u0431\u044a\u0435\u043a\u0442\u0430\u043c \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u044d\u0442\u043e \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043f\u0443\u0442\u0438 \u043f\u0443\u0442\u0438 \u043a \u0444\u0430\u0439\u043b\u0430\u043c, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043d\u044b\u043c c\u043b\u0443\u0436\u0431\u043e\u0439 \u0442\u0435\u043d\u0435\u0432\u043e\u0433\u043e \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u043e\u043c\u043e\u0432: </p> <p><code>\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1_</code></p> <p>\u0422\u0430\u043a\u0436\u0435 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043e\u0448\u0438\u0431\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u0434\u0430\u043d\u044b \u0432\u044b\u0437\u0432\u0430\u043d\u043d\u044b\u043c \u043c\u0435\u0442\u043e\u0434\u043e\u043c Windows API.</p> <p></p> <p>\u0421\u043e\u0432\u0435\u0442</p> <p>\u0414\u043e\u0441\u0442\u0443\u043f \u043a <code>CopyFile</code> \u0440\u0430\u0441\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u043e\u0441\u0442\u043e\u0433\u043e \u0431\u0430\u0437\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0430. \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u044b\u0439 \u043f\u043e\u0434\u0445\u043e\u0434 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0434\u0440\u0443\u0433\u0438\u043c Windows API.</p>"},{"location":"ru/#_2","title":"\u0421\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u0435","text":"<ul> <li>\u0422\u0440\u0438 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u043c\u0435\u0442\u043e\u0434 Windows API<ul> <li>\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 Add-Type \u0434\u043b\u044f \u0432\u044b\u0437\u043e\u0432\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API</li> <li>\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e .NET \u043c\u0435\u0442\u043e\u0434\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044e Windows API</li> <li>\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API \u0438\u0437 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430</li> </ul> </li> <li>\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435</li> </ul> <p>\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435</p> <p>\u041d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u044b \u0435\u0449\u0435 \u043d\u0435 \u0437\u0430\u043a\u043e\u043d\u0447\u0435\u043d\u044b, \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u0434\u043e\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442\u0441\u044f.</p>"},{"location":"ru/#_3","title":"\u041f\u0440\u0438\u043c\u0435\u0440\u044b \u043a\u043e\u0434\u0430","text":"<p>\u041f\u0440\u0438\u043c\u0435\u0440\u044b \u0438\u0437 \u044d\u0442\u043e\u0439 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u043d\u0430 GitHub: powershell-winapi-tutorial/examples/.</p>"},{"location":"ru/summary/","title":"\u0417\u0430\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435","text":"<p>This article content is not ready yet\u2026</p>"},{"location":"ru/win32-approaches/","title":"\u0422\u0440\u0438 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u043c\u0435\u0442\u043e\u0434 Windows API","text":"<p>\u0424\u0443\u043d\u043a\u0446\u0438\u0438 Windows API \u0445\u043e\u0440\u043e\u0448\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0442 \u0434\u043b\u044f \u043d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0445 \u0437\u0430\u0434\u0430\u0447, \u0442\u043e\u0433\u0434\u0430 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0442\u0435\u0441\u043d\u043e\u0435 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u0441 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439. \u0415\u0441\u0442\u044c \u0442\u0440\u0438 \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a Windows API \u0438\u0437 PowerShell:</p> <ol> <li>\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 Add-Type \u0434\u043b\u044f \u0432\u044b\u0437\u043e\u0432\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API</li> <li>\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e .NET \u043c\u0435\u0442\u043e\u0434\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044e Windows API</li> <li>\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API \u0438\u0437 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430</li> </ol> <p>\u0412 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u0435 \u0441\u043b\u0443\u0447\u0430\u0435\u0432 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u0431\u0443\u0434\u0435\u0442 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e, \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0440\u043e\u0441\u0442 \u0438 \u043f\u0440\u044f\u043c\u043e\u043b\u0438\u043d\u0435\u0435\u043d. \u041d\u043e \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u0443\u0447\u0435\u0441\u0442\u044c \u0447\u0442\u043e <code>Add-Type</code> \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 C# (css.exe) \u0438 \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u043d\u0430 \u0434\u0438\u0441\u043a, \u0447\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u043e\u0439 \u0432 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u044f\u0445. \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0434\u0432\u0430 \u0434\u0440\u0443\u0433\u0438\u0445 \u0441\u043f\u043e\u0441\u043e\u0431\u0430, \u0435\u0441\u043b\u0438 \u0436\u0435\u043b\u0430\u0435\u0442\u0435 \u043c\u0438\u043d\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0441\u043b\u0435\u0434, \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u044b\u0439 \u0432\u0430\u0448\u0438\u043c \u0441\u043a\u0440\u0438\u043f\u0442\u043e\u043c \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u0435.</p> <p>\u0411\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u043e Windows API \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0443\u0436\u0435 \u0438\u043c\u0435\u044e\u0442 \u043c\u0435\u0442\u043e\u0434\u044b-\u043e\u0431\u0435\u0440\u0442\u043a\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c .NET API, \u043d\u043e \u044d\u0442\u0438 \u043c\u0435\u0442\u043e\u0434\u044b \u043c\u043e\u0433\u0443\u0442 \u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0441\u044f \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u043c\u0438. \u0412\u0442\u043e\u0440\u043e\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043d\u0435\u043c\u0443.</p> <p>\u0422\u0440\u0435\u0442\u0438\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0437\u0430\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u0432 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 \u043e\u0442\u0440\u0430\u0436\u0435\u043d\u0438\u044f (\u0440\u0435\u0444\u043b\u0435\u043a\u0441\u0438\u0438) \u0434\u043b\u044f \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u043a\u043e\u0434\u0430 \u0432\u044b\u0437\u043e\u0432\u0430 Windows API \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u042d\u0442\u043e\u0442 \u043f\u043e\u0434\u0445\u043e\u0434 \u043f\u043e\u043b\u0435\u0437\u0435\u043d, \u0435\u0441\u043b\u0438 \u0442\u0440\u0435\u0431\u0443\u0435\u043c\u0430\u044f \u043e\u0431\u0435\u0440\u0442\u043a\u0430 Windows API \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430 \u0432 .NET \u0441\u0431\u043e\u0440\u043a\u0430\u0445, \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u043d\u044b\u0445 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u043c \u0441\u0435\u0430\u043d\u0441\u0435 PowerShell, \u0438 \u0432\u044b \u0442\u0430\u043a\u0436\u0435 \u043d\u0435 \u0445\u043e\u0442\u0438\u0442\u0435 \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u043d\u0430 \u0434\u0438\u0441\u043a\u0435.</p> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u043d\u0438\u0436\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u043c\u043e\u0447\u044c \u0432\u0430\u043c \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0441\u043f\u043e\u0441\u043e\u0431.</p> \u041a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442 Add-Type \u041f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 .NET \u0414\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u0421\u043b\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u041d\u0438\u0437\u043a\u0430\u044f \u0421\u0440\u0435\u0434\u043d\u044f\u044f \u0412\u044b\u0441\u043e\u043a\u0430\u044f \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0414\u0430 \u041d\u0435\u0442 \u041d\u0435\u0442 \u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u0430\u044f \u0432 .NET \u043e\u0431\u0435\u0440\u0442\u043a\u0430 \u041d\u0435\u0442 \u0414\u0430 \u041d\u0435\u0442"},{"location":"ru/win32-approaches/add-type/","title":"\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 Add-Type \u0434\u043b\u044f \u0432\u044b\u0437\u043e\u0432\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API","text":"<p>\u041a\u043e\u043c\u043c\u0430\u043d\u0434\u043b\u0435\u0442 Add-Type \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 .NET \u043a\u043b\u0430\u0441\u0441 \u0432 \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0441\u0435\u0430\u043d\u0441 PowerShell. \u0414\u0430\u043d\u043d\u0430\u044f \u0441\u0442\u0430\u0442\u044c\u044f \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 \u0434\u043b\u044f \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0444\u0443\u043d\u043a\u0446\u0438\u0438 CopyFile, \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u043d\u043e\u0439 \u0432 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0435  kernel32.dll.</p>"},{"location":"ru/win32-approaches/add-type/#_1","title":"\u0411\u0430\u0437\u043e\u0432\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f","text":"<p>\u0420\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0441\u043a\u0440\u0438\u043f\u0442, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u044e <code>CopyFile</code>:</p> PowerShell<pre><code>$MethodDefinition = @'\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\npublic static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);\n'@\n$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -Namespace 'Win32' -PassThru\n$Kernel32::CopyFile(\"$($Env:SystemRoot)\\System32\\calc.exe\", \"$($Env:USERPROFILE)\\Desktop\\calc.exe\", $False)\n</code></pre> <p>\u042d\u0442\u043e\u0442 \u0441\u043a\u0440\u0438\u043f\u0442 \u0434\u0435\u043b\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435:</p> <ul> <li> <p>\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f <code>$MethodDefinition</code> \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u0430 \u043d\u0430 C#, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0435 \u0441\u0438\u0433\u043d\u0430\u0442\u0443\u0440\u0435 <code>CopyFile</code> \u043d\u0430 C++:</p> \u0420\u0430\u0437\u0432\u0435\u0440\u043d\u0438\u0442\u0435, \u0447\u0442\u043e\u0431\u044b \u0443\u0432\u0438\u0434\u0435\u0442\u044c \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 <p>\u0421\u0438\u0433\u043d\u0430\u0442\u0443\u0440\u0430 \u043c\u0435\u0442\u043e\u0434\u0430 \u043d\u0430 C++<pre><code>BOOL CopyFile(\n    [in] LPCTSTR lpExistingFileName,\n    [in] LPCTSTR lpNewFileName,\n    [in] BOOL    bFailIfExists\n);\n</code></pre> \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u0430 \u043d\u0430 C#<pre><code>[DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\npublic static extern bool CopyFile(\n    string lpExistingFileName,\n    string lpNewFileName,\n    bool   bFailIfExists\n);\n</code></pre></p> <p>\u0410\u0442\u0442\u0440\u0438\u0431\u0443\u0442 DllImport \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u0447\u0442\u043e \u043c\u0435\u0442\u043e\u0434 <code>CopyFile</code> \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u0432 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0435 kernel32.dll \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0432\u0445\u043e\u0434\u0430.</p> <p>\u041e\u0431\u0440\u0430\u0442\u0438\u0442\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u043d\u0430 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u044f \u0442\u0438\u043f\u043e\u0432 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0432 \u0421++ \u0438 \u0432 .NET \u043a\u043e\u0434\u0435:</p> \u0422\u0438\u043f C/C++ \u0422\u0438\u043f .NET BOOL bool LPCTSTR string </li> <li> <p>\u041a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442 <code>Add-Type</code> \u0441\u043e\u0437\u0434\u0430\u0435\u0442 \u043a\u043b\u0430\u0441\u0441 <code>Kernel32</code>, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u043c\u0435\u0442\u043e\u0434 <code>CopyItem</code>, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0437\u0430\u0434\u0430\u043d\u043e \u043d\u0430 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c \u0448\u0430\u0433\u0435.</p> </li> <li> <p>\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043a\u043e\u0434\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u043c\u0435\u0442\u043e\u0434 <code>Kernel32::CopyFile</code> \u0434\u043b\u044f \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430 calc.exe \u0438\u0437 \u043f\u0430\u043f\u043a\u0438 Windows\\System32 \u043d\u0430 \u0440\u0430\u0431\u043e\u0447\u0438\u0439 \u0441\u0442\u043e\u043b.</p> </li> </ul>"},{"location":"ru/win32-approaches/add-type/#_2","title":"\u0414\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0438\u0435 \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044f","text":"<ul> <li>\u0420\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 C# \u043a\u043e\u0434\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u043e\u0439 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 PowerShell \u0441\u043a\u0440\u0438\u043f\u0442\u0430 \u043c\u043e\u0436\u0435\u0442 \u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0441\u044f \u043d\u0435\u0443\u0434\u043e\u0431\u043d\u044b\u043c. \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c C# \u043a\u043e\u0434 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u0444\u0430\u0439\u043b\u0430 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 Get-Content.</li> <li>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043e\u0431\u044a\u044f\u0432\u0438\u0442\u044c \u043a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442 <code>Copy-RawItem</code> \u0432 \u0441\u0432\u043e\u0435\u043c PowerShell \u043c\u043e\u0434\u0443\u043b\u0435 \u2014 \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u043b\u0435\u0433\u0447\u0438\u0442\u044c \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u0434\u0430.</li> <li>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043e\u0448\u0438\u0431\u043e\u043a \u2014 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043d\u0435\u0443\u0434\u0430\u0447\u043d\u043e\u043c \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0438 <code>CopyFile</code>.</li> </ul> <p>\u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043d\u0438\u0436\u0435 \u043a\u043e\u0434 \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u0443\u0435\u0442 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043c\u043e\u0434\u0443\u043b\u044f CopyRawItem.psm1 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0432\u044b\u0448\u0435\u0438\u0437\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0445 \u0434\u043e\u0440\u0430\u0431\u043e\u0442\u043e\u043a:</p> \u041c\u043e\u0434\u0443\u043b\u044c PowerShell<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $MethodDefinition = Get-Content -Path .\\CopyFile.cs\n    $Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name 'Kernel32' -Namespace 'Win32' -PassThru\n    $CopyResult = $Kernel32::CopyFile($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists']))\n    if ($CopyResult -eq $False) {\n        throw New-Object ComponentModel.Win32Exception(\n            [System.Runtime.InteropServices.Marshal]::GetLastWin32Error())\n    }\n    else {\n        Write-Output (Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>\u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0442 \u043c\u043e\u0434\u0443\u043b\u044c \u0438 \u0432\u044b\u0437\u0432\u0430\u0442\u044c <code>Copy-RawItem</code> \u0438\u0437 \u0432\u0430\u0448\u0435\u0433\u043e \u0441\u043a\u0440\u0438\u043f\u0442\u0430 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c:</p> PowerShell<pre><code>Import-Module ./CopyRawItem.psm1\nCopy-RawItem \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\System32\\config\\SAM C:\\temp\\SAM -FailIfExists\n</code></pre> <p>\u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u0435, \u0444\u0430\u0439\u043b \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u0438\u0441\u043f\u0435\u0442\u0447\u0435\u0440\u0430 \u0443\u0447\u0451\u0442\u043d\u044b\u0445 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0438\u0437 \u0442\u0435\u043d\u0435\u0432\u043e\u0439 \u043a\u043e\u043f\u0438\u0438 \u0442\u043e\u043c\u0430 \u0432\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u043f\u0430\u043f\u043a\u0443 (\u0447\u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u0430\u043d\u0434\u043b\u0435\u0442\u0430 Copy-Item). \u0415\u0441\u043b\u0438 \u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c <code>Copy-RawItem</code> \u0434\u0432\u0430\u0436\u0434\u044b, \u0432\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0443 \u201cThe file exists\u201d:</p> <p></p> <p>\u041f\u0440\u0438 \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u043d\u0435\u0432\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0443\u0442\u0438 \u0432\u044b\u0434\u0430\u0435\u0442\u0441\u044f \u043e\u0448\u0438\u0431\u043a\u0430 \u201cThe system cannot find the path specified\u201d.</p> <p>\u0421\u043e\u0432\u0435\u0442</p> <p>\u0415\u0441\u043b\u0438 \u0432\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442\u0435 \u043e\u0448\u0438\u0431\u043a\u0443 \u201cAccess is denied\u201d \u043f\u0440\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u0435 \u043a \u0442\u0435\u043d\u0435\u0432\u043e\u0439 \u043a\u043e\u043f\u0438\u0438, \u043f\u0435\u0440\u0435\u0437\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u0441\u0435\u0430\u043d\u0441 PowerShell \u043e\u0442 \u0438\u043c\u0435\u043d\u0438 \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430.</p> <p>\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435</p> <p>\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0437\u0434\u0435\u0441\u044c \u043a\u043e\u0434 \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043d\u0430 GitHub: powershell-winapi-tutorial/examples/add-type.</p>"},{"location":"ru/win32-approaches/private-method/","title":"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u043e\u0433\u043e .NET \u043c\u0435\u0442\u043e\u0434\u0430, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044e Windows API","text":"<p>\u0422\u0435\u043a\u0441\u0442 \u0434\u043b\u044f \u044d\u0442\u043e\u0439 \u0441\u0442\u0430\u0442\u044c\u0438 \u043f\u043e\u043a\u0430 \u043d\u0435 \u0433\u043e\u0442\u043e\u0432\u2026</p> PowerShell Module<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $mscorlib = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { \n        $_.Location -and ($_.Location.Split('\\')[-1] -eq 'mscorlib.dll')\n    }\n    $Win32Native = $mscorlib.GetType('Microsoft.Win32.Win32Native')\n    $CopyFileMethod = $Win32Native.GetMethod(\n        'CopyFile', ([Reflection.BindingFlags] 'NonPublic, Static'))\n    $CopyResult = $CopyFileMethod.Invoke(\n        $null, @($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists'])))\n    $HResult = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\n    if ($CopyResult -eq $False -and $HResult -ne 0) {\n        throw New-Object ComponentModel.Win32Exception($HResult)\n    }\n    else {\n        Write-Output(Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435</p> <p>\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0437\u0434\u0435\u0441\u044c \u043a\u043e\u0434 \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043d\u0430 GitHub: powershell-winapi-tutorial/examples/private-method.</p>"},{"location":"ru/win32-approaches/reflection/","title":"\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 Windows API \u0438\u0437 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430","text":"<p>\u0422\u0435\u043a\u0441\u0442 \u0434\u043b\u044f \u044d\u0442\u043e\u0439 \u0441\u0442\u0430\u0442\u044c\u0438 \u043f\u043e\u043a\u0430 \u043d\u0435 \u0433\u043e\u0442\u043e\u0432\u2026</p> PowerShell Module<pre><code>function Copy-RawItem {\n    [CmdletBinding()]\n    [OutputType([System.IO.FileSystemInfo])]\n    Param (\n        [Parameter(Mandatory = $True, Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Destination,\n        [Switch]\n        $FailIfExists\n    )\n    $DynAssembly = New-Object System.Reflection.AssemblyName('Win32Lib')\n    $AssemblyBuilder = [AppDomain]::CurrentDomain.DefineDynamicAssembly(\n        $DynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)\n    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('Win32Lib', $False)\n    $TypeBuilder = $ModuleBuilder.DefineType('Kernel32', 'Public, Class')\n    $PInvokeMethod = $TypeBuilder.DefineMethod('CopyFile', [Reflection.MethodAttributes] 'Public, Static',\n        [Bool], [Type[]] @([String], [String], [Bool]))\n    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))\n    $FieldArray = [Reflection.FieldInfo[]] @(\n        [Runtime.InteropServices.DllImportAttribute].GetField('EntryPoint'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('PreserveSig'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('CallingConvention'),\n        [Runtime.InteropServices.DllImportAttribute].GetField('CharSet')\n    )\n    $FieldValueArray = [Object[]] @(\n        'CopyFile',\n        $True,\n        $True,\n        [Runtime.InteropServices.CallingConvention]::Winapi,\n        [Runtime.InteropServices.CharSet]::Unicode\n    )\n    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder(\n        $DllImportConstructor, @('kernel32.dll'), $FieldArray, $FieldValueArray)\n    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)\n    $Kernel32 = $TypeBuilder.CreateType()\n    $CopyResult = $Kernel32::CopyFile($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists']))\n    if ($CopyResult -eq $False) {\n        throw New-Object ComponentModel.Win32Exception(\n            [System.Runtime.InteropServices.Marshal]::GetLastWin32Error())\n    }\n    else {\n        Write-Output (Get-ChildItem $Destination)\n    }\n}\n</code></pre> <p>\u041f\u0440\u0438\u043c\u0435\u0447\u0430\u043d\u0438\u0435</p> <p>\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0437\u0434\u0435\u0441\u044c \u043a\u043e\u0434 \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u043d\u0430 GitHub: powershell-winapi-tutorial/examples/reflection.</p>"}]}